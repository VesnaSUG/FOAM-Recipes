<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Intro](#intro)
- [Initial Setup](#initial-setup)
- [Generate Application](#generate-application)
  - [Application Structure](#application-structure)
  - [FOAM Model - Recipe.js](#foam-model---recipejs)
    - [Understanding FOAM Models](#understanding-foam-models)
  - [FOAM Journals](#foam-journals)
    - [FOAM DAO Service](#foam-dao-service)
    - [Menu Navigation](#menu-navigation)
- [Running Application](#running-application)
- [Testing](#testing)
  - [Running Tests](#running-tests)
  - [Creating Modeled Test Cases](#creating-modeled-test-cases)
    - [Server-Side Tests (Java)](#server-side-tests-java)
    - [Client-Side Tests (JavaScript)](#client-side-tests-javascript)
  - [Test Organization](#test-organization)
    - [Directory Structure](#directory-structure)
    - [Registering Tests](#registering-tests)
    - [Adding Tests to the POM](#adding-tests-to-the-pom)
    - [Understanding POM Flags](#understanding-pom-flags)
  - [Running Tests from the Application UI](#running-tests-from-the-application-ui)
  - [Test Configuration](#test-configuration)
- [Modify FOAM Recipe Model](#modify-foam-recipe-model)
  - [Adding Enum and Autogenerated IDs](#adding-enum-and-autogenerated-ids)
  - [Default Table Columns and Filters](#default-table-columns-and-filters)
  - [Journal Merging](#journal-merging)
- [Placeholder](#placeholder)
- [Appendix](#appendix)
  - [FOAM Model Reference](#foam-model-reference)
    - [Properties](#properties)
      - [Property Class Requirement](#property-class-requirement)
      - [Basic Property Syntax](#basic-property-syntax)
      - [Property Types by Category](#property-types-by-category)
      - [Object and Reference Properties](#object-and-reference-properties)
      - [Collection Properties](#collection-properties)
      - [Property Features](#property-features)
    - [Methods](#methods)
    - [Listeners](#listeners)
    - [Actions](#actions)
  - [Source-to-Sink Architecture](#source-to-sink-architecture)
    - [The Sink Interface](#the-sink-interface)
    - [Source-to-Sink Flow](#source-to-sink-flow)
    - [Common Built-in Sinks](#common-built-in-sinks)
      - [ArraySink - Collect Results](#arraysink---collect-results)
      - [Count - Count Matching Objects](#count---count-matching-objects)
      - [GroupBy - Group Results](#groupby---group-results)
      - [Map - Transform Results](#map---transform-results)
    - [Streaming Architecture](#streaming-architecture)
    - [Custom Sinks](#custom-sinks)
    - [Sink Delegation](#sink-delegation)
    - [DAO Composition vs Sink Delegation](#dao-composition-vs-sink-delegation)
    - [Practical Example](#practical-example)
    - [Summary](#summary)
  - [Journal Merging In-Depth](#journal-merging-in-depth)
    - [Static vs Runtime Journals](#static-vs-runtime-journals)
    - [Development vs Production Deployment](#development-vs-production-deployment)
    - [How Journal Concatenation Works](#how-journal-concatenation-works)
    - [Journal Directory Conventions](#journal-directory-conventions)
    - [Practical Example: The Demo User](#practical-example-the-demo-user)
    - [Using the -J Flag](#using-the--j-flag)
    - [Creating Your Own Deployment Configuration](#creating-your-own-deployment-configuration)
    - [Feature Flags and Conditional Compilation](#feature-flags-and-conditional-compilation)
    - [Exporting Runtime Data to Static Journals](#exporting-runtime-data-to-static-journals)
    - [Journal Precedence Summary](#journal-precedence-summary)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Intro

This tutorial will guide you through creating of a new project using FOAM. FOAM stands for "Feature-Oriented Active Modeller", and it is a framework converting high-level software specifications, called "models", into useful executable software components, called "features". FOAM is cross-language and cross-platform, meaning that it can be used as JS, Java and Swift, and for both client and server software.

The tutorial will cover the initial setup and an application creation by creating a cooking recipe database. The tutorial assumes that you 
already have <code>Java</code>, <code>Node.js</code> and <code>Maven</code> installed in your environment. If you need to install these, helpful tips can be found in the [FOAM installation instructions][foam-install]. This tutorial also assumes that if you are using a Windows device, you are using WSL.

> [!IMPORTANT]
> Note that you do not need to build FOAM in isolation for the tutorial. We will do this step when we add FOAM as a git sub-module to our project.

By following this tutorial you will learn to:
1. Initialize a new FOAM application 
1. Define FOAM models
1. Familiarize with DAOs
1. Understand journals
1. ...

This tutorial is best suited for FOAM beginners as well as experienced FOAM developers who wish to understand the underlying architecture in more depth.


# Initial Setup

If you are starting from scratch the best way to start is with an empty github repository you own. You can find more information on how to create a new github repository [here][github-docs-repo]. 
After you created a github repo for your project, the first step is to clone it into your development environment:

```
git clone <git URL for your repository>
cd <project root>
```

Alternatively you can work with a local project that you can add remote tracking to at later time. 

```
mkdir <project root>
cd <project root>
git init
```

One of the conveniences of FOAM is that allows customizations (called "refinements") to the predefined models. For that reason, FOAM is included in your project as a GIT sub-module, instead of a package.
Therefore our next step is to go to the [FOAM Repository][foam-repo] and grab the repository's URL, then link to it as a sub-module for our project. Here is an example how to do it using the ssh github link:

```
git submodule add git@github.com:kgrgreer/foam3.git
git submodule update --init --recursive --rebase --force
```

The FOAM build depends on a few generic npm packages. Install them with:

```
#cd into the foam3 sub-module directory
cd foam3/
./build.sh --install
```

# Generate Application

The easiest way to create a FOAM application is to use the foam build script <code>foam3/tools/build.js</code> and generate the application structure and the main application model. To create your application this way,
while still in the *foam3* directory, execute the following:

```
# from foam3 directory
./build.sh -T+setup/Project --appName:Recipe --package:com.foamdev.cook --adminPassword:badpassword
# cd back to your root directory
cd ..
```

In this case, we named the application and the top model _Recipe_ and placed it in the _com.foamdev.cook_ package.

## Application Structure

Your application directory should now look similar to this:

```
/deployment
  /demo
  /test
/journals
/foam3
/src
pom.js
build.sh
.gitignore
.gitmodules
```

Let's examine a few key files before we run our application. 

One of the generated files is *build.sh* with the following content:

```
#!/bin/bash
node foam3/tools/build.js "$@"
```

This is a convenience script to make the application builds easier. Before you use it, make sure that the script has executable privileges:

```
chmod +x build.sh
```

The next file to take a look at is the Project Object Model (POM) file for our project, named pom.js. Note that this file is a meta project file that will be used by FOAM to generate the traditional POM.xml used by build tools. The file should have the following content:

```
foam.POM({
  name: 'recipes',
  excludes: [ '*' ],
  projects: [
    { name: 'foam3/pom'},
    { name: 'src/com/foamdev/cook/pom'},
    { name: 'journals/pom' }
  ],
  licenses: `
    // Add your license header here
  `,
  envs: {
    version: '1.0.0',
    // javaMainArgs: 'spid:recipes'
  },
  tasks: [
    function javaManifest() {
      JAVA_MANIFEST_VENDOR_ID = 'cook.foamdev.com';
    }
  ]
});

```

Let's look briefly at the purpose of each of the elements in this file:

<table>
<thead>
<tr>
<th width=20%>Name</th>
<th width=80%>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td width=20% align="left">name</td>
<td width=80% align="left">The name of your project. Will be used for naming certain files and directories created by the build process.</td>
</tr>
<tr>
<td width=20% align="left">excludes</td>
<td width=80% align="left">By default the FOAM build will recurse sub-directories, unless they are included in excludes. The directories listed
are standard directories that we want to FOAM build to ignore. The <b>*</b> turns off all defaults. The build will only include projects listed
in the projects below.</td>
</tr>
<tr>
<td width=20% align="left">projects</td>
<td width=80% align="left">Points to pom files for other projects or sub-projects. At the very minimum, you need to include the foam3/pom to include foam. You can break your project into multiple pom files, or just have one top-level pom.</td>
</tr>
<tr>
<td width=20% align="left">licenses</td>
<td width=80% align="left">An array of license notifications. When the build creates a deployment .js file, it will include all declared licenses at the top.</td>
</tr>
<tr>
<td width=20% align="left">VERSION</td>
<td width=80% align="left">The version that will be attached to some built files. Should be updated when you make a new release so that old cached code isn't used.</td>
</tr>
<tr>
<td width=20% align="left">tasks</td>
<td width=80% align="left">Tasks are build hooks that allow the pom to modify build properties.  In this case when the build is creating the Java JAR Manifest file, this pom sets the vendor id property.</td>
</tr>
</tbody>
</table>


You can learn more on the pom file and possible customization options by reading the full [FOAM POM specification][foam-pom-spec].

## FOAM Model - Recipe.js

The most interesting file that is generated for us is the model file Recipe.js in the src/com/foamdev/cook directory. The file contains the key entity for our recipe database application. We will adjust the content of this file as we develop our application. However, if you just generated the project, the file will have the following content:

```
foam.CLASS({
  package: 'com.foamdev.cook',
  name: 'Recipe',

  implements: [
    'foam.core.auth.CreatedAware',
    'foam.core.auth.LastModifiedAware'
  ],

  tableColumns: [
    'name',
    'description'
  ],

  searchColumns: [
    'name',
    'description'
  ],

  properties: [
    {
      class: 'Long',
      name: 'id',
      createVisibility: 'HIDDEN',
      updateVisibility: 'RO'
    },
    {
      class: 'String',
      name: 'name',
      required: true
    },
    {
      class: 'String',
      name: 'description'
    }
  ],

  methods: [
    function sampleMethod() {
      return 'Hello World!';
    },
    function toSummary() {
      return this.name;
    },
    function toString() {
      return this.toSummary();
    }
  ]
});

```

Here we defined a model for class <code>Recipe</code> that is in the <code>com.foamdev.cook</code> package and has two properties,
<code>name</code> and <code>description</code>, a few sample methods. The model derives
from two interfaces, <code>foam.core.auth.CreatedAware</code> and <code>foam.core.auth.LastModifiedAware</code> whose default implementation adds the timestamp and last modified properties.

### Understanding FOAM Models

A FOAM model is a high-level specification that FOAM compiles into executable code for multiple languages (JavaScript, Java, Swift). The `foam.CLASS()` declaration defines everything about a class in one place - its data, behavior, relationships, and metadata.

Here's the anatomy of a FOAM class definition:

```javascript
foam.CLASS({
  package: 'com.example.project',     // Java-style package namespace
  name: 'MyModel',                    // Class name
  extends: 'foam.core.BaseModel',     // Single inheritance (optional)
  implements: [                       // Interfaces/traits (optional)
    'foam.core.auth.CreatedAware',
    'foam.core.auth.LastModifiedAware'
  ],
  requires: [                         // Dependencies for context-aware creation
    'foam.dao.ArraySink',
    'com.example.project.OtherModel'
  ],
  imports: ['userDAO', 'currentUser'], // Inject from context
  exports: ['selectedItem'],           // Export to child context

  properties: [ ... ],                 // Data members
  methods: [ ... ],                    // Instance methods
  listeners: [ ... ],                  // Pre-bound callback methods
  actions: [ ... ]                     // User-triggered operations
});
```

**Key Model Sections:**

| Section | Purpose |
|---------|---------|
| `package` + `name` | Fully qualified class identifier |
| `extends` | Single parent class inheritance |
| `implements` | Mix in interfaces/traits for shared behavior |
| `requires` | Declare dependencies for context-aware object creation |
| `imports` / `exports` | Context-based dependency injection |
| `properties` | Typed data members with validation, defaults, and reactivity |
| `methods` | Instance functions; can have both `code` (JS) and `javaCode` |
| `listeners` | Methods pre-bound to `this`; safe to use as callbacks |
| `actions` | User-triggered operations with UI integration |

We will explore each of these concepts in detail as we develop our Recipe application. For a comprehensive reference, see [FOAM Model Reference](#foam-model-reference) in the Appendix.

## FOAM Journals

 A journal is a simple JSON-like configuration file used to store application data. Journal files are suitable for simple configuration data containing only a few records, and for larger in-memory databases, potentially containing millions of records. Journal files are append-only, meaning when data is added, updated, or removed, changes are only appended to the end of the file, but none of its contents are updated or removed. Updates are performed by recoding, or journalling, a list of desired changes. These changes will appear in the journal as either "create" lines:
```
  c({<json-data-here>});
```
or "put" (update) lines:
```
  p({<json-data-here>});
```
or "remove" lines:
```
  r({<json-id-here>});
```
For the run-time journals, before each update there may be a line which declares who made the change and when they made it:
```
  // Modified by Kevin Greer (49393173) at 2025-05-20T14:53:26.590-0400
```
The run-time journals also add a `version` line noting a change in the application version.
```
  v({"version":<application-version>})
```
The advantages of journal files are that they can be updated quickly, no old data is lost (and so updates or reverts can be reversed),
they are human readable, they provide an audit trail of who and when changes were made, they're very fault tolerant, don't require external
database hosting or configuration, and provide excellent performance for many use-cases.

For our example, groups, menus, permissions, and services journals are under <code>journals</code> directory. 


### FOAM DAO Service

We'll gain more understanding on the content of the generated journal files as we go. For now, let's focus on the journal file <code>journals/services.jrl</code> that sets up one of the key FOAM services, DAO:

```
p({
  "class": "foam.core.boot.CSpec",
  "name": "recipeDAO",
  "description": "",
  "serve": true,
  "authenticate": true,
  "keywords": [ "recipe" ],
  "serviceScript": """
    return new foam.dao.EasyDAO.Builder(x)
      .setOf(com.foamdev.cook.Recipe.getOwnClassInfo())
      .setPm(true)
      .setSeqNo(true)
      .setAuthorize(false)
      .setJournalType(foam.dao.JournalType.SINGLE_JOURNAL)
      .build();
  """,
  "client": `{"of":"com.foamdev.cook.Recipe"}`
})
```
The FOAM core comes with a number of out-of-the-box services, with DAO service being one of them, that you'll become more 
familiar with time. With the journal above, we add the recipes DAO service to FOAM.

A DAO, or Data Access Object, is an object which provides access to a collection of data. Here is a simplified pseudo code for the DAO interface:

```
interface DAO {
  FObject  put(obj)
  FObject  find(id)
  FObject  remove(obj)
  void     removeAll()
  Sink     select(sink)
  void     listen(sink)
  void     unlisten(sink)
  DAO      where(predicate)
  DAO      limit(count)
  DAO      skip(count)
  DAO      orderBy(...comparators)
  DAO      inX(x)
}
```

> [!IMPORTANT]
> DAO methods are asynchronous. In JavaScript, this is expressed by wrapping return values in Promises. For example, `put()` returns `Promise<FObject>`, `find()` returns `Promise<FObject>`, and `select()` returns `Promise<Sink>`. Use `.then()` or `await` to access the results.

A Sink is a destination object that receives and processes query results from `select()`. Here is the Sink interface:

```
interface Sink {
  void  put(obj, sub)
  void  remove(obj, sub)
  void  eof()
  void  reset(sub)
}
```

FObject (Feature Object) is the base class for all FOAM modeled objects. When you define a model with `foam.CLASS()`, FOAM generates a class that extends FObject. FObjects provide:

- **Properties** with automatic getters/setters, validation, and change notification
- **Methods** that can be implemented in JavaScript, Java, or both
- **Serialization** to/from JSON for storage and network transfer
- **Cloning, comparison, and hashing** out of the box

With a DAO you can do everything you might want to do with a collection of data. The above interface is surprisingly general and powerful, despite its relatively small size. Also note that a DAO is an interface, not a specific implementation. There are many DAO implementations that let you
store your data in different underlying databases or other storage mechanisms. No mater which DAO implementation you're using, they all have the same interface and your client code can work with any implementation without change. Journal files, for example, are accessed through the "JDAO" DAO implementation.

Learn more about DAOs in the [Introduction to FOAM Programming][foam-intro] and by inspecting the [model][foam-dao] for the DAO interface. For an in-depth explanation of how DAOs and Sinks work together, see [Source-to-Sink Architecture](#source-to-sink-architecture) in the Appendix.


### Menu Navigation 

Let's look at one more file, <code>journals/menus.jrl</code> before we run our application. A **menu** is used to make our entity
visible in FOAM. Upon initial creation the file should have the following content:

```
p({
  "class":"foam.core.menu.Menu",
  "id":"recipes.recipe",
  "label":"Recipe",
  "authenticate":true,
  "keywords":[""],
  "handler":{
    "class":"foam.core.menu.DAOMenu2",
    "config":{
      "class":"foam.comics.v2.DAOControllerConfig",
      "daoKey":"recipeDAO"
    }
  }
})
```

# Running Application

The last step before we can run our application is to assure that the needed helper directories /opt and /opt/recipe directories exist and you are set as the owner:

```
sudo chown -R $USER /opt
```

Now we are ready to test our code. From the command line, in your root directory type:

```
$ deployment/demo/run.sh
# or
$ ./build.sh -Jdemo
```

This will trigger the build and start the server. You can open your application in the web browser at http://localhost:8080/. 
Use one of the following credentials at the logging screen:

```
# administrator - full access
user: admin
password: badpassword

# regular non-priveledged user - can only interact with Recipes.
user: demo
password: demopassword
```

Clicking on the Recipe in the left navigation menu should bring you to the Recipe screen:

![app-screen-1][app-screen-1]

Notice how much functionality you already have by just creating a simple model and connecting to the FOAM core. 

Another interesting thing to point out is the presence of the demo user. If you recall in the setup script we only added the admin. The demo user however is only 
available if you run the application with the option <code>-Jdemo</code>. This instructs the application to load the additional journals, in this case <code>deployment/demo</code>
that was copied for by the setup script. You can create your own journals that you can use this way, by going to the runtime journals directory under /opt and lifting the entries into
a different file, then including it at startup with the <code>-J</code> option. For more info see the chapter on [Journal Merging](#Journal-Merging).

> [!IMPORTANT]
> To stop the FOAM server, type in <code>CTRL</code>+C twice.

# Testing

FOAM provides a testing harness for implementing unit tests. Test cases can be either modeled FOAM classes or scripts, and can target both Java (server-side) and JavaScript (client-side).

## Running Tests

Tests are executed using build tasks:

```bash
# Run all server and client tests
./build.sh run-tests

# Run only server-side (Java) tests
./build.sh server-tests

# Run only client-side (JavaScript) tests
./build.sh client-tests

# Run specific test cases by id
./build.sh run-tests:RecipeTest,RecipeTestMethods

# Exclude specific tests (prefix with -)
./build.sh run-tests:-SlowTest,-IntegrationTest
```

Test output shows success or failure for each test:

```
RecipeTest
   ✓ SUCCESS: ID empty before create
   ✓ SUCCESS: ID set after create
```

## Creating Modeled Test Cases

Test cases are FOAM models that extend a test base class. Place tests in a `test` subdirectory within your package.

### Server-Side Tests (Java)

For Java tests, extend `foam.core.test.Test` and implement `runTest` with `javaCode`. Here's our example from <code>src/com/foamdev/cook/test/RecipeTest.js</code>:

```javascript
foam.CLASS({
  package: 'com.foamdev.cook.test',
  name: 'RecipeTest',
  extends: 'foam.core.test.Test',

  javaImports: [
    'com.foamdev.cook.*',
    'foam.dao.DAO'
  ],

  methods: [
    {
      name: 'runTest',
      javaCode: `
        var recipe = new Recipe();
        test(recipe.getId() == 0l, "ID empty before create");

        recipe = (Recipe) ((DAO) x.get("recipeDAO")).put(recipe);
        test(recipe.getId() != 0l, "ID set after create");
      `
    }
  ]
});
```

### Client-Side Tests (JavaScript)

For JavaScript tests, extend `foam.core.test.JSTest` and implement `runTest` as a JavaScript function. Here's an example from <code>src/com/foamdev/cook/test/RecipeTestMethods.js</code>:

```javascript
foam.CLASS({
  package: 'com.foamdev.cook.test',
  name: 'RecipeTestMethods',
  extends: 'foam.core.test.JSTest',

  requires: [ 'com.foamdev.cook.Recipe' ],

  methods: [
    {
      name: 'runTest',
      args: ['Context x'],
      code: function runTest(x) {
        // debugger;
        let recipe = this.Recipe.create();
        x.test(recipe.toSummary() == "", 'Recipe toSummary is initially empty');

        recipe.name = 'Fried chicken';
        x.test(recipe.toSummary() == "Fried chicken", 'Recipe toSummary is equal to name');
      }
    }
  ]
});
```

Note: In Java tests, call `test(condition, message)` directly. In JavaScript tests, call `x.test(condition, message)` using the context parameter.

## Test Organization

### Directory Structure

Tests live in a `test` subdirectory within your package:

```
src/com/foamdev/cook/
├── Recipe.js
├── RecipeCategory.js
├── pom.js
└── test/
    ├── RecipeTest.js        (Java server test)
    ├── RecipeTestMethods.js (JavaScript client test)
    ├── tests.jrl            (test registration)
    └── pom.js               (test pom)
```

### Registering Tests

Tests must be registered in a `tests.jrl` journal file. Each test case needs an entry:

```javascript
p({
  "class": "com.foamdev.cook.test.RecipeTest",
  "id": "RecipeTest",
  "description": "Recipe Id tests"
})

p({
  "class": "com.foamdev.cook.test.RecipeTestMethods",
  "id": "RecipeTestMethods",
  "description": "Test Recipe methods in JavaScript",
  "language": 0
})
```

### Adding Tests to the POM

Create a `pom.js` in your test directory and reference it from the parent pom with the `test` flag:

**test/pom.js:**
```javascript
foam.POM({
  name: 'test',
  files: [
    { name: 'RecipeTest',        flags: 'js|java' },
    { name: 'RecipeTestMethods', flags: 'js|java' }
  ]
});
```

### Understanding POM Flags

The `flags` property in POM file entries controls which build tasks include the file for processing:

- **`js`** - Include in JavaScript build tasks (bundling for client-side)
- **`java`** - Include in Java build tasks (compilation for server-side)
- **`js|java`** - Include in both JavaScript and Java builds (the `|` means OR)
- **`test`** - Only include when running test tasks
- **`js&test`** - Include in JavaScript builds only when testing (the `&` means AND)

The flags determine *when* a file is processed, not *what* is generated from it. A FOAM model with `flags: 'js|java'` will be included in both build pipelines—FOAM then determines what to generate based on the model's content (e.g., `javaCode` blocks generate Java, JavaScript functions remain JavaScript).

For test files, use `js|java` so the model is available to both build pipelines. The base class determines the test type: `foam.core.test.Test` creates server-side Java tests, while `foam.core.test.JSTest` creates client-side JavaScript tests.

When referencing a test directory from a parent POM, use `flags: 'test'` so test code is only included during test runs, not in production builds.

## Running Tests from the Application UI

For test-driven development, you can include test infrastructure in a running application by adding `--flags:test` to your build command:

```bash
./build.sh -Jdemo --flags:test
```

Once the application is running, log in and navigate to the test menu at `#admin-tests`. From this interface you can:

- Browse all registered test cases
- Run individual JavaScript (client-side) tests interactively
- View test results immediately
- Use "Run Client" to execute all JavaScript tests
- Use "Run Failed Client" to re-run only previously failed tests

This workflow is particularly powerful for debugging because you can set breakpoints in your browser's developer tools and step through the code as tests execute. When a test fails, you can:

1. Open the browser's developer tools (F12)
2. Set breakpoints in your test code or the code being tested
3. Run the failing test from the UI
4. Step through the execution to understand why it fails
5. Fix the issue and re-run until the test passes

This tight feedback loop—running tests with full debugger support—makes test-driven development practical and efficient. You can even include `debugger;` statements in your test code (as shown in the RecipeTestMethods example) to automatically pause execution at specific points.

Note: Running server-side tests from the UI is not recommended as it may cause the UI to become unresponsive. For server tests, use the command-line `server-tests` task instead.

**Parent pom.js (src/com/foamdev/cook/pom.js):**
```javascript
foam.POM({
  name: 'recipe',
  projects: [
    { name: 'test/pom', flags: 'test' }
  ],
  files: [
    { name: 'Recipe',         flags: 'js|java' },
    { name: 'RecipeCategory', flags: 'js|java' }
  ]
});
```

The `flags: 'test'` ensures the test directory is only included when running tests.

## Test Configuration

If tests require additional configuration (test data, mock services, etc.), place those journals in `deployment/test/`. The build automatically includes this deployment directory when running tests.

For more details, see the [FOAM Testing Guide][foam-testing-guide].

# Modify FOAM Recipe Model

Our <code>Recipe</code> model is not very interesting yet. Ultimately, we would like to have the following as our schema to create a relevant recipe database:

![recipe-schema][recipe-schema]

## Adding Enum and Autogenerated IDs

Let's start by adjusting the <code>Recipe</code> model. Since <code>Recipe</code> references a recipe type ENUM, let's create a model for that categorization first by creating a file <code>src/com/foamdev/cook/RecipeCategory.js</code> with the following content:

```
foam.ENUM({
  package: 'com.foamdev.cook',
  name: 'RecipeCategory',
  values: [
    { name: 'APPETIZER' },
    { name: 'MAIN' },
    { name: 'DESSERT' },
    { name: 'BEVERAGE' },
    { name: 'SNACK' },
    { name: 'SIDE' },
    { name: 'OTHER' }
  ]
});
```

The next step is to go to the <code>src/com/foamdev/cook/Recipe.js</code> and adjust the content to the following:

```
foam.CLASS({
  package: 'com.foamdev.cook',
  name: 'Recipe',

  implements: [
    'foam.core.auth.CreatedAware',
    'foam.core.auth.LastModifiedAware'
  ],

  tableColumns: [
    'name',
    'description'
  ],

  searchColumns: [
    'name',
    'category'
  ],

  properties: [
    {
      class: 'Long',
      name: 'id',
      createVisibility: 'HIDDEN',
      updateVisibility: 'RO'
    },
    {
      class: 'String',
      name: 'name',
      required: true
    },
    {
      class: 'Enum',
      of: 'com.foamdev.cook.RecipeCategory',
      name: 'category',
      value: 'OTHER'
    },
    {
      class: 'String',
      name: 'description'
    }
  ],

  methods: [
    function sampleMethod() {
      return 'Hello World!';
    },
    function toSummary() {
      return this.name;
    },
    function toString() {
      return this.toSummary();
    }
  ]
});
```

Here we added two new properties, the <code>id</code> and <code>category</code> property. The possible values for the category property are the values enumerated in the <code>RecipeCategory</code> ENUM we created earlier. 

What is interesting about the other field that we added, the <code>id</code>, is that the values for this field are autogenerated, unique ids.  Since the user won't entering this value, we are giving FOAM instruction to omit it from the create screen by setting <code>createVisibility</code> to <code>HIDDEN</code>. Also, given that the property is not editable, we also adjusted <code>updateVisibility</code> to read-only.

Before we can run the modified application, we need to include the new model that we created for the <code>RecipeCategory</code> in the build by adjusting the POM file for the package <code>src/com/foamdev/cook/pom.js</code>:

```
foam.POM({
  name: 'recipe',
  projects: [
    { name: 'test/pom',                 flags: 'test' }
  ],
  files: [
    { name: 'Recipe',                  flags: 'js|java' },
    { name: 'RecipeCategory',          flags: 'js|java' }
  ]
});

```

## Default Table Columns and Filters


Let's create some test data by clicking on the <code>Create a New Recipe</code> button to create a few recipe instances.
Notice that only the <code>name</code> and <code>description</code> are shown by default in the list view because those are the only two
fields that we defined in the <code>tableColumns</code> section above. You can adjust which fields are shown by clicking on the "..." and selecting
additional fields. To reset to the default view, click on the <code>Reset Columns</code>.

![app-screen-2][app-screen-2]


Another interesting setting you should we aware of is which filters are shown by default. The filters are useful to narrow down your search to a certain category:

![app-screen-3][app-screen-3]

You can always adjust the default table columns and filters by editing the <code>tableColumns</code> and <code>searchColumns</code> in your model:

```
  tableColumns: [
    'id',
    'name',
    'category',
    'description'
  ],

  searchColumns: [
    'name',
    'category'
  ],
```

## Journal Merging

FOAM's journal merging system allows you to layer configuration for different environments (development, testing, production) without maintaining separate codebases. The build concatenates `.jrl` files from your source tree into static journals (`.0`), which are then combined with runtime journals at startup.

The `-J` flag lets you include environment-specific journals from the `deployment/` directory:

```bash
# Include deployment/demo/ journals (adds demo user)
./build.sh -Jdemo

# Include multiple deployment configurations
./build.sh -Jdemo,https
```

For a comprehensive explanation of journal merging, including static vs runtime journals, concatenation order, deployment conventions, and production builds, see [Journal Merging In-Depth](#journal-merging-in-depth) in the Appendix.

# Placeholder
// TODO - to be continued ...

* -generate the app again to adjust the structure (but manually modify this one to match)
* add a section on the high level system structure and some core services
* add a deep dive on models and long form
* add a section on views, and custom views
* add a section on debugging tips
* further develop the app to demonstrate all key concepts in the cheat sheet
* add a section on services
* create the rest of the models "off-line" and zip them for download (correct the schema to fully match)
* create some meaningful full entries and "import" them, explain search filtering feature
* test the clone mode and write up README.md how to run if you do not follow along
* add the tutorial as MD to foam3 (this would make it easier for claude code to use as guidance, the first step could be just to add it to the doc/guides)



# Appendix

## FOAM Model Reference

This section provides detailed documentation for FOAM model components. For the basic anatomy, see [Understanding FOAM Models](#understanding-foam-models) in the main tutorial.

### Properties

Properties are typed data members that define the data structure of a FOAM model.

#### Property Class Requirement

All properties **must** have a `class` defined unless they are pure JavaScript (untyped). The `class` specifies the property type and must be a class derived from `Property` (defined in `foam.lang`).

Since `foam.lang` is included by default, you can use short names like `String` instead of the full path `foam.lang.String`. FOAM provides many predefined property types in `foam/lang/types.js`.

Here is an example of how to define properties in a model:

```javascript
properties: [
  // Typed property - class is required for cross-language support
  {
    class: 'String',              // Short form (foam.lang.String)
    name: 'name',
    required: true
  },

  // Untyped property - pure JavaScript only, no Java/Swift generation
  'description'                   // Equivalent to { name: 'description' }
]
```

> **Note:** Untyped properties (just a name string) work in JavaScript but won't generate proper Java or Swift code. Always use typed properties for cross-language models.

#### Property Definition (Abridged from Property.js)

All property types extend `foam.lang.Property`. Here are the key options available:

```javascript
foam.CLASS({
  package: 'foam.lang',
  name: 'Property',

  properties: [
    'name',           // Required: property identifier
    'label',          // UI label (defaults to name "labelized")
    'documentation',  // Developer-level documentation
    'help',           // User-level help text for UI
    { class: 'Boolean', name: 'hidden' },    // Hide from UI
    { class: 'Boolean', name: 'required' },  // Cannot be null/undefined/empty

    // Default values
    'value',          // Static default value
    'factory',        // Function returning default (runs once on first access)
    'expression',     // Reactive function (recalculates when dependencies change)

    // Value transformation callbacks (in order)
    'adapt',          // Transform value to appropriate type
    'assertValue',    // Validate and throw if invalid
    'preSet',         // Called before value updated (can modify value)
    'postSet',        // Called after value updated

    // Advanced
    'getter',         // Custom getter replacing normal process
    'setter',         // Custom setter replacing normal process
    'final',          // Can only be set once (read-only after)
    'transient',      // Not persisted to storage/network
    ...
  ]
});
```

#### Commonly Used Property Types

FOAM provides many predefined property types in `foam/lang/types.js`:

- **Numeric:** `Int`, `Long`, `Float`, `Double`, `Short`, `Byte`, `UnitValue`, `Duration`
- **String:** `String`, `EMail`, `Password`, `URL`, `Code`, `PhoneNumber`, `Color`, `Image`
- **Date/Time:** `Date`, `DateTime`, `DateTimeUTC`, `Time`
- **Boolean:** `Boolean`
- **Enum:** `Enum` (requires `of` to specify the enum class)
- **Object:** `FObjectProperty` (embedded by value), `Reference` (by ID)
- **Collections:** `Array`, `StringArray`, `FObjectArray`, `Map`

#### Object and Reference Properties

Two property types are particularly important for modeling relationships between FOAM objects: `FObjectProperty` and `Reference`. Both use the `of` property to specify the target FOAM class, but they differ in how they store the relationship.

**FObjectProperty - Embedded Objects (By Value):**

Stores a complete FOAM object **by value**, embedded inline with its parent. Use this when the child object is owned by and stored with the parent.

```javascript
{
  class: 'FObjectProperty',
  of: 'com.example.Address',      // The FOAM class this property holds
  name: 'address',
  factory: function() {           // Create default instance
    return this.Address.create();
  }
}
```

The `of` property specifies the FOAM class type. The entire Address object is serialized and stored as part of the parent object.

**Reference - Foreign Key Relationship (By Reference):**

Stores only the **ID** of another object, not the object itself. Use this when objects are stored separately (in different DAOs) and you need a relationship between them.

```javascript
{
  class: 'Reference',
  of: 'com.example.User',         // The FOAM class being referenced
  name: 'authorId',
  targetDAOKey: 'userDAO'         // DAO where the referenced object lives
}
```

The `Reference` property:
- Stores only the ID value (lightweight, like a foreign key in SQL)
- The `of` property specifies what type of object this ID refers to
- `targetDAOKey` specifies which DAO to use to look up the full object
- FOAM UI automatically creates links to navigate to the referenced object

**Comparison:**

| Aspect | FObjectProperty | Reference |
|--------|-----------------|-----------|
| Storage | Entire object embedded | Only ID stored |
| `of` meaning | Type of embedded object | Type of referenced object |
| Use case | Owned child objects | Relationships to external objects |
| Serialization | Object included inline | Just the ID value |


#### Property Examples

**Numeric properties:**
```javascript
{ class: 'Int', name: 'count', min: 0, max: 100 }
{ class: 'Long', name: 'id' }
{ class: 'Float', name: 'price', precision: 2 }
```

**String properties:**
```javascript
{ class: 'String', name: 'name', trim: true, width: 50 }
{ class: 'EMail', name: 'email' }      // Auto-lowercase, trimmed
{ class: 'Password', name: 'secret' }  // Hidden text
```

**Date/Time properties:**
```javascript
{ class: 'Date', name: 'birthDate' }      // Date only (normalized to noon UTC)
{ class: 'DateTime', name: 'createdAt' }  // Date and time
```

**Boolean property:**
```javascript
{ class: 'Boolean', name: 'isActive', value: false }
```

**Enum property** (first define the enum, then reference it):
```javascript
// Define the enum
foam.ENUM({
  package: 'com.example',
  name: 'Status',
  values: [
    { name: 'DRAFT',     label: 'Draft' },
    { name: 'PUBLISHED', label: 'Published' },
    { name: 'ARCHIVED',  label: 'Archived' }
  ]
});

// Use in a property
{ class: 'Enum', of: 'com.example.Status', name: 'status', value: 'DRAFT' }
```

#### Collection Properties

**Array:**

```javascript
{
  class: 'Array',
  name: 'tags',
  factory: function() { return []; }
}
// Helper methods: tags$push(item), tags$remove(predicate), tags$filter(predicate)
```

**StringArray:**

```javascript
{
  class: 'StringArray',
  name: 'keywords'
}
```

**FObjectArray - Array of FOAM Objects:**

```javascript
{
  class: 'FObjectArray',
  of: 'com.example.Ingredient',
  name: 'ingredients'
}
```

**Map:**

```javascript
{
  class: 'Map',
  name: 'metadata'
}
// Helper methods: metadata$set(key, value), metadata$remove(key)
```

#### Property Features

**Defaults:**
- `value` - Static default (parsed at model build time)
- `factory` - Function returning default (runs once on first access)
- `expression` - Reactive computation (recalculates when dependencies change)

```javascript
// Static default
{ class: 'Int', name: 'count', value: 0 }

// Factory - runs once when first accessed
{ class: 'Array', name: 'items', factory: function() { return []; } }

// Expression - reactive, recalculates when dependencies change
{
  class: 'String',
  name: 'fullName',
  expression: function(firstName, lastName) {
    return firstName + ' ' + lastName;
  }
}
```

**Validation and Transformation:**
- `required` - Property must have a value
- `adapt` - Transform value before setting
- `preSet` - Hook before value is set (can modify value)
- `postSet` - Hook after value is set

```javascript
{
  class: 'String',
  name: 'email',
  required: true,
  preSet: function(old, nu) {
    return nu.toLowerCase().trim();
  },
  postSet: function(old, nu) {
    console.log('Email changed from', old, 'to', nu);
  }
}
```

**Visibility Controls:**

```javascript
{
  class: 'Long',
  name: 'id',
  createVisibility: 'HIDDEN',     // Hidden when creating new objects
  updateVisibility: 'RO',         // Read-only when editing
  readVisibility: 'RO'            // Read-only in detail views
}
// Values: 'RW' (read-write), 'RO' (read-only), 'HIDDEN', 'DISABLED'
```

**Other Common Options:**
- `transient: true` - Not persisted to storage/network
- `hidden: true` - Hidden from all views
- `documentation: '...'` - Inline documentation
- `label: 'Display Name'` - UI label (defaults to property name)
- `help: '...'` - Help text for users

### Methods

Methods can be defined in short or long form:

```javascript
methods: [
  // Short form - JavaScript only
  function toSummary() {
    return this.name;
  },

  // Long form - supports both JavaScript and Java
  {
    name: 'calculateTotal',
    args: [
      { name: 'items', type: 'Array' },
      { name: 'taxRate', type: 'Float' }
    ],
    type: 'Float',
    code: function(items, taxRate) {
      var subtotal = items.reduce((sum, item) => sum + item.price, 0);
      return subtotal * (1 + taxRate);
    },
    javaCode: `
      float subtotal = 0;
      for (var item : items) subtotal += item.getPrice();
      return subtotal * (1 + taxRate);
    `
  }
]
```

### Listeners

Listeners are methods that are **pre-bound** to `this`. Use them as callbacks that will be passed around the system but need to execute with the correct context:

```javascript
listeners: [
  {
    name: 'onDataChange',
    code: function() {
      // 'this' is always the object instance, even when called externally
      console.log('Data changed:', this.name);
      this.refresh();
    }
  },
  {
    name: 'onButtonClick',
    // Optional: debounce/throttle frequent events
    isMerged: true,        // Merge rapid calls into one
    delay: 100,            // Wait 100ms before executing
    code: function(event) {
      this.handleClick(event);
    }
  }
]
```

### Actions

Actions are user-initiated operations that can be displayed as buttons in the UI:

```javascript
actions: [
  {
    name: 'save',
    label: 'Save Recipe',
    icon: 'save',
    isEnabled: function(name) { return !!name; },  // Enable only if name exists
    code: function() {
      this.recipeDAO.put(this);
    }
  },
  {
    name: 'delete',
    label: 'Delete',
    confirmationRequired: true,
    code: function() {
      this.recipeDAO.remove(this);
    }
  }
]
```

## Source-to-Sink Architecture

In **FOAM**, DAOs and Sinks are explicitly separated. A **Sink** is an interface used specifically with the `select()` operation to process query results as they stream from the data source.

### The Sink Interface

A Sink is a destination object that receives and processes query results:

```javascript
// Basic pattern
dao.select(sink);
```

### Source-to-Sink Flow

- **Source**: The DAO containing the data you're querying
- **Sink**: The destination object that receives/accumulates results
- **Flow**: `select()` streams objects from the DAO (source) to the Sink (destination)

**A note on Promises:** The `select()` method returns a JavaScript Promise. When you call `.then((sink) => { ... })`, the `sink` parameter is the successful return value—a copy of the sink containing the results. Always use this returned sink to access results, not the original sink you passed in. You can also use `async/await` syntax:

```javascript
// Using .then()
dao.select(foam.dao.ArraySink.create()).then((sink) => {
  console.log(sink.array);
});

// Using async/await (equivalent)
var sink = await dao.select(foam.dao.ArraySink.create());
console.log(sink.array);
```

### Common Built-in Sinks

#### ArraySink - Collect Results

```javascript
// ArraySink - collects results into an array
dao.select(foam.dao.ArraySink.create()).then((sink) => {
  console.log(sink.array); // All results
});
```

#### Count - Count Matching Objects

```javascript
// Count - counts matching objects
dao.select(foam.mlang.sink.Count.create()).then((sink) => {
  console.log(sink.value); // Number of results
});
```

#### GroupBy - Group Results

```javascript
// GroupBy - groups results by property with count
dao.select(foam.mlang.sink.GroupBy.create({
  arg1: MyModel.CATEGORY,
  arg2: foam.mlang.sink.Count.create()
})).then((sink) => {
  console.log(sink.groups); // Grouped results with counts
});
```

#### Map - Transform Results

The `Map` sink transforms each result using an **expression**. The `arg1` property expects an object that implements the `foam.mlang.F` interface, which defines an `f(obj)` method that takes an object and returns a transformed value.

```javascript
// Map using a property reference (properties implement the F interface)
dao.select(foam.mlang.sink.Map.create({
  arg1: MyModel.ID,  // Property reference extracts the ID from each object
  delegate: foam.dao.ArraySink.create()
})).then((sink) => {
  console.log(sink.delegate.array); // Array of ID values
});

// Map using a custom expression with the f() method
dao.select(foam.mlang.sink.Map.create({
  arg1: { f: function(obj) { return obj.name.toUpperCase(); } },
  delegate: foam.dao.ArraySink.create()
})).then((sink) => {
  console.log(sink.delegate.array); // Array of uppercase names
});

// Using the FUNC helper for custom transformations (requires foam.mlang.predicate.Func)
dao.select(this.MAP(
  this.FUNC(function(obj) { return { id: obj.id, label: obj.name }; }),
  foam.dao.ArraySink.create()
)).then((sink) => {
  console.log(sink.delegate.array); // Array of {id, label} objects
});
```

> **Note:** The `foam.mlang.F` interface is fundamental to FOAM's expression system. Any object with an `f(obj)` method can be used as an expression. This includes property references (e.g., `MyModel.NAME`), built-in expressions (e.g., `ADD`, `DOT`), and custom expression objects.

### Streaming Architecture

FOAM's sink pattern enables **streaming query results** from the source DAO to the destination Sink. The fluent query API allows you to specify filtering, pagination, and ordering before executing the query:

```javascript
// Build query specification, then execute with select()
dao
  .where(this.EQ(this.Todo.IS_COMPLETED, true))
  .skip(40)
  .limit(20)
  .select(sink);
```

In this example:
- **Predicates**: `this.EQ()` is a FOAM predicate expression (from the `mlang` library) that creates an equality comparison. Other predicates include `GT`, `LT`, `GTE`, `LTE`, `AND`, `OR`, `NOT`, `CONTAINS`, etc. To use them, add the predicates to your model's `requires` array (e.g., `'foam.mlang.predicate.Eq'`), then reference them via `this.Eq.create()` or the shorthand `this.EQ()`.
- **Query specification**: `where()`, `skip()`, and `limit()` build up the query parameters
- **Execution**: `select(sink)` executes the query against the DAO (source)
- **Streaming**: Results flow from the DAO to the Sink (destination)
- **Processing**: The Sink receives each matching object via its `put()` method

### Custom Sinks

You can create custom sinks to process data as it flows:

```javascript
foam.CLASS({
  name: 'CustomSink',
  implements: ['foam.dao.Sink'],

  methods: [
    function put(obj, sub) {
      // Process each object as it arrives
      console.log('Received:', obj);
      // Do custom processing, aggregation, etc.

      // Optionally stop receiving more results:
      // sub.detach();
    },

    function eof() {
      // Called when stream is complete
      console.log('All data received');
    }
  ]
});
```

The `sub` parameter in `put(obj, sub)` is a **subscription** (implementing `foam.lang.Detachable`) that gives the sink control over the data stream. Calling `sub.detach()` signals that the sink no longer wants to receive more objects, allowing the DAO to stop processing early. This is useful for implementing limits or early termination - for example, FOAM's built-in `LimitedSink` uses `sub.detach()` to stop after receiving the requested number of results.

This JavaScript-only sink works because when querying a remote DAO (e.g., over HTTP), FOAM internally uses an `ArraySink` to transport results across the network. The results are then copied to your custom sink on the client side, calling `put()` for each object.

For sinks that need to execute on both client and server, provide both JavaScript and Java implementations:

```javascript
foam.CLASS({
  name: 'CustomSink',
  implements: ['foam.dao.Sink'],

  methods: [
    {
      name: 'put',
      args: [
        { name: 'obj', type: 'FObject' },
        { name: 'sub', type: 'Detachable' }
      ],
      code: function put(obj, sub) {
        // JavaScript implementation (client-side)
        console.log('Received:', obj);
      },
      javaCode: `
        // Java implementation (server-side)
        System.out.println("Received: " + obj);
      `
    },

    {
      name: 'eof',
      code: function eof() {
        console.log('All data received');
      },
      javaCode: `
        System.out.println("All data received");
      `
    }
  ]
});
```

When a sink has both `code` (JavaScript) and `javaCode`, the **sink itself** can be executed on either the client or server depending on where the DAO operation is performed.

**Why server-side sink execution matters:** If a sink only has JavaScript code, data must be transferred from the server to the client *before* the sink can process it. For operations like counting or aggregation, this is inefficient - you'd transfer thousands of objects just to count them. When a sink has `javaCode`, it can execute directly on the server where the data resides. Only the *result* (e.g., a count value, a sum, grouped totals) is sent back to the client, dramatically reducing network traffic.

For example, FOAM's built-in `Count` sink has both JavaScript and Java implementations. When you call `dao.select(COUNT())` against a server-side DAO, the counting happens on the server and only the final count number is returned - not every object in the DAO.

### Sink Delegation

Sinks can be **composed** through delegation, where one sink processes results and passes them to a delegate sink for further processing:

```javascript
// Filter → Transform → Collect (via delegation)
var sink = foam.dao.PredicatedSink.create({
  predicate: someCondition,
  delegate: foam.mlang.sink.Map.create({
    arg1: MyModel.NAME,  // Expression to extract/transform (required)
    delegate: foam.dao.ArraySink.create()
  })
});

dao.select(sink);
```

In this pattern:
- `PredicatedSink` filters incoming results based on `predicate`
- Filtered results are delegated to `Map` which applies the `arg1` expression
- Transformed results are delegated to `ArraySink` for collection

This is **delegation**, not chaining - each sink delegates to the next rather than forming a pipeline.

### DAO Composition vs Sink Delegation

It's important to distinguish between DAO composition and Sink delegation:

**DAO Composition**: DAOs can be decorated/wrapped to form processing layers (like caching, logging, filtering). Operations flow through the decorated DAOs before reaching the underlying storage.

**Sink Delegation**: The destination for `select()` results. Some sinks delegate internally to other sinks for multi-stage result processing.

**The Flow**:
```
Decorated DAOs → select() → Sink (with possible delegation)
     ↑                              ↓
  (composition)              (delegation)
```

### Practical Example

Count active users by department:

```javascript
// Query active users and group by department with count
userDAO
  .where(this.EQ(User.STATUS, 'active'))
  .select(this.GROUP_BY(User.DEPARTMENT))
  .then((sink) => {
    // sink.groups contains department → count mapping
    console.log(sink.groups);
  });
```

Note: This example uses the short form `this.GROUP_BY()` compared to the long form `foam.mlang.sink.GroupBy.create()` shown earlier. Also, `arg2` defaults to `Count`, so you only need to specify it if you want a different aggregation sink.

### Summary

In **FOAM, "source to sink"** specifically refers to the flow of query results from a DAO (source) through the `select()` operation to a Sink interface (destination) that processes or accumulates those results. It's a clean separation between data storage (DAO) and result processing (Sink).

## Journal Merging In-Depth

As you develop your application, you'll often need different configurations for different environments—development, testing, production, demos, etc. FOAM's journal merging system provides an elegant solution: rather than maintaining separate codebases or complex environment variables, you simply layer journal files that override or extend your base configuration.

### Static vs Runtime Journals

FOAM distinguishes between two types of journals:

- **Static journals (`.0`)** - Built at compile time by concatenating `.jrl` files from your source tree. The build process produces files with the `.0` extension (e.g., `services.0`) in the `build/journals/` directory. These are read-only and represent your application's base configuration.
- **Runtime journals** - Written during application execution when data changes. These capture all creates, updates, and deletes made while the application runs. Historically these used a `.1` extension, though this naming convention is legacy and no longer applied.

During application startup, FOAM replays the static journals (`.0`) first, then applies the runtime journals on top. This ensures that your base configuration is loaded, followed by any changes made during previous runs.

### Development vs Production Deployment

How static journals are deployed differs between development and production environments:

**Development (local builds)**

For local development, the `.0` static journals are copied directly into the `/opt/<app root>/journals/` directory—the same directory where runtime journals will be created during application execution. This makes it easy to inspect and debug the merged journal content.

```
/opt/recipe/
├── journals/
│   ├── services.0              (static journal - copied from build)
│   ├── menus.0                 (static journal - copied from build)
│   ├── com.foamdev.cook.Recipe (runtime journal - created at runtime)
│   └── ...
└── lib/
    └── ...
```

**Production (Docker/JAR builds)**

For production deployments and Docker builds, the `.0` static journals are packed into a resources JAR file placed in the `/opt/<app root>/lib/` directory. FOAM reads them directly from the JAR file—they are not unpacked. This means the `/opt/<app root>/journals/` directory contains only runtime journals.

Production builds are created using `build.sh` with specific build tasks. Run `./build.sh --help` to see available options, or consult the [FOAM Build Guide][foam-build-guide] for detailed instructions on creating production and Docker deployments.

```
/opt/recipe/
├── journals/
│   ├── com.foamdev.cook.Recipe (runtime journal only)
│   └── ...
└── lib/
    ├── recipe-resources.jar    (contains .0 static journals)
    └── ...
```

This approach keeps the production deployment cleaner and ensures static configuration cannot be accidentally modified.

### How Journal Concatenation Works

The build process finds and concatenates same-named journal files (`.jrl`) into a single static journal (`.0`). The concatenation follows the POM project structure:

1. **Start at the root** where your main `pom.js` is located
2. **Recurse into subdirectories**, but stop when encountering a directory that has its own `pom.js`
3. **Process each project** listed in the `projects` section of `pom.js`, applying the same recursion rule to each

Looking at our application's `pom.js`:

```javascript
foam.POM({
  name: 'recipes',
  projects: [
    { name: 'foam3/pom'},
    { name: 'src/com/foamdev/cook/pom'},
    { name: 'journals/pom' }
  ],
  // ...
});
```

The build processes journals in project order. For `services.jrl`, this means:

```
1. foam3/.../services.jrl files        (FOAM's base services)
2. src/com/foamdev/cook/services.jrl   (if present)
3. journals/services.jrl               (your application services)
        ↓
   build/journals/services.0           (merged static journal)
```

When you add `-Jdemo`, the deployment directory is processed after the main projects:

```
4. deployment/demo/services.jrl        (demo-specific overrides)
        ↓
   build/journals/services.0           (merged static journal)
```

### Journal Directory Conventions

FOAM follows these conventions for organizing journal files:

- **Deployment journals** (`<project root>/deployment/`) - Contains environment-specific configurations selected at startup with the `-J` flag. Each subdirectory (e.g., `demo/`, `test/`, `https/`) represents a deployment scenario. When using `-J`, you omit the `deployment/` prefix—so `-Jdemo` refers to `deployment/demo/`.

- **Application journals** (`<project root>/journals/`) - Contains your application's base configuration that applies to all deployments. This location is a convention, not a requirement. You could place these journals elsewhere, as long as they're included via your POM's `projects` list.

The key distinction is that deployment journals are selected at startup depending on the environment (development, testing, production), while application journals are included in every build as long as their directory is listed in your main `pom.js` projects.

### Practical Example: The Demo User

Remember when we ran the application with `./build.sh -Jdemo` and a `demo` user was available? Let's see how this works.

Look at the file `deployment/demo/users.jrl`:

```
p({
  "class": "foam.core.auth.User",
  "id": 1001,
  "userName": "demo",
  "email": "demo@example.com",
  "firstName": "Demo",
  "lastName": "User",
  "group": "basicUser",
  "desiredPassword": "demopassword"
})
```

This user only exists when you build with `-Jdemo`. Without that flag, the demo user journal is never merged, and the user doesn't exist. This is how you can:

- Add test users for QA environments
- Configure different services for staging vs. production
- Enable debug features only in development builds

### Using the -J Flag

The `-J` flag tells the build which deployment directories to include. The `deployment/` prefix is implicit—you only specify the subdirectory name:

```bash
# Include deployment/demo/ journals
./build.sh -Jdemo

# Include multiple: deployment/demo/ and deployment/https/
./build.sh -Jdemo,https

# Include deployment/test/ journals
./build.sh -Jtest
```

Each comma-separated value corresponds to a subdirectory under `deployment/`. The build will process journal files in that directory and concatenate them into the static journals (`.0`).

### Creating Your Own Deployment Configuration

Let's create a deployment configuration with some sample recipe data. First, create a new deployment directory:

```bash
mkdir -p deployment/sample-data
```

Create `deployment/sample-data/recipes.jrl` with some recipes:

```
p({
  "class": "com.foamdev.cook.Recipe",
  "id": 1,
  "name": "Classic Pancakes",
  "category": "MAIN",
  "description": "Fluffy buttermilk pancakes perfect for breakfast"
})

p({
  "class": "com.foamdev.cook.Recipe",
  "id": 2,
  "name": "Chocolate Chip Cookies",
  "category": "DESSERT",
  "description": "Chewy cookies with melted chocolate chunks"
})

p({
  "class": "com.foamdev.cook.Recipe",
  "id": 3,
  "name": "Fresh Lemonade",
  "category": "BEVERAGE",
  "description": "Refreshing summer drink with fresh lemons"
})
```

Now run your application with this sample data:

```bash
./build.sh -Jdemo,sample-data
```

Your application will start with both the demo user and the sample recipes pre-loaded.

### Feature Flags and Conditional Compilation

Journal merging also enables conditional feature inclusion. If a source directory has a POM file that isn't referenced by your main POM tree, that feature won't be included in your build by default.

However, a deployment directory can reference that feature's POM, effectively "enabling" it. This is how FOAM implements optional features:

1. **Feature source** exists at `src/foam/dao/compaction/` with its own `pom.js`
2. **Deployment** at `deployment/compaction/` references this source POM
3. Building with `-Jcompaction` includes both the deployment journals AND the source code

This pattern lets you ship optional features that customers can enable without modifying core application code.

### Exporting Runtime Data to Static Journals

As you use the application, data changes are appended to runtime journals under your application home directory (typically `/opt/<app root>/journals/`). You can "export" this data back into your source `.jrl` files so it becomes part of the static journals (`.0`) for version control:

1. Find the runtime journal (e.g., `/opt/recipe/journals/com.foamdev.cook.Recipe`)
2. Copy relevant entries to a deployment `.jrl` file
3. Check the deployment journal into version control

On rebuild, your exported entries will be concatenated into the static journal (`.0`). This is useful for:
- Creating reproducible demo environments
- Sharing test data with your team
- Seeding new deployments with initial data

### Journal Precedence Summary

During concatenation into static journals (`.0`), when the same object ID appears in multiple `.jrl` files, the last occurrence wins. Since deployment directories are processed after the main POM projects:

```
journals/menus.jrl:        p({"id":"recipe.main", "label":"Recipes"})
deployment/demo/menus.jrl: p({"id":"recipe.main", "label":"Demo Recipes"})
                                                   ↓
build/journals/menus.0:    label = "Demo Recipes"
```

Similarly, runtime journals are replayed after static journals (`.0`), so any changes made during application execution will override the static configuration.


[FOAM Guides][foam-guides]

<!-- List all links here -->

[foam-repo]: https://github.com/kgrgreer/foam3
[foam-pom-spec]: https://github.com/kgrgreer/foam3/blob/development/doc/guides/POM.md
[foam-build-guide]: https://github.com/kgrgreer/foam3/blob/development/doc/guides/Build.md
[foam-testing-guide]: https://github.com/kgrgreer/foam3/blob/development/doc/guides/Testing.md
[foam-install]: https://github.com/kgrgreer/foam3/blob/development/INSTALL.md
[foam-intro]: https://docs.google.com/presentation/d/1yT6Yb5aJJ3OXD3n_8GKC_vtTs_rxJpzOQRgU1Oa_1r4/edit?usp=sharing
[github-docs-repo]: https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository
[app-screen-1]: images/screen1.png
[app-screen-2]: images/screen2.png
[app-screen-3]: images/screen3.png
[recipe-schema]: images/RecipeDBSchema.png
[github-ssh]: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
[foam-dao]: https://github.com/kgrgreer/foam3/blob/development/src/foam/dao/DAO.js
[foam-guides]: https://github.com/kgrgreer/foam3/tree/development/doc/guides
